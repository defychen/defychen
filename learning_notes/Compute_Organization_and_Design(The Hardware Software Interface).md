# Compute Organization and Design(The Hardware/Software Interface)

## Chapter 1 计算机概要与技术

### 1.1 引言

#### 1.1.1 常用容量表示方法

1.KB/MB/GB/TB/PB/EB/ZB/YB的意思

	KB(kilobyte):数值为10^3;
	MB(megabyte):数值为10^6;
	GB(gigabyte):数值为10^9;
	TB(terabyte):数值为10^12;
	PB(petabyte):数值为10^15;
	EB(exabyte):数值为10^18;
	ZB(zettabyte):数值为10^21;
	YB(yottabyte):数值为10^24.

2.KiB/MiB/GiB/TiB/PiB/EiB/ZiB/YiB的意思

	KiB(kibibyte):数值为2^10;
	MiB(mebibyte):数值为2^20;
	GiB(gibibyte):数值为2^30;
	TiB(tebibyte):数值为2^40;
	PiB(pebibyte):数值为2^50;
	EiB(exbibyte):数值为2^60;
	ZiB(zebibyte):数值为2^70;
	YiB(yobibyte):数值为2^80.

#### 1.1.2 一些常用概念

	1.PMD(Personal Mobile Device):个人移动设备;
		e.g.智能手机或平板电脑;
	2.云计算(cloud computing):替代传统的服务器,建立在WSG(Warehouse Scale Compute:仓储规模计算机)巨
	型数据中心之上.Amazon和Google构建了含有100 000台服务器的WSG,一些公司可以租用其中不部分为PMD提供软
	件服务,而不用自己构建WSG;
	3.SaaS(Software as a Service):软件即服务,在网络上以服务的方式提供软件和数据.运行方式通常不是在本地
	设备上运行所有的二进制代码,而是通过诸如运行在本地客户端的浏览器等小程序登录到远程服务器上执行.
		e.g.Web搜索和社交网络.

### 1.2 计算机系统结构中的8个伟大思想

	1.面向摩尔定律的设计;
	2.使用抽象简化设计;
	3.加速大概率事件;
	4.通过并行提高性能;
	5.通过流水线提高性能;
	6.通过预测提高性能;
	7.存储器层次;
	8.通过冗余提高可靠性.

### 1.3 制造技术相关概念

#### 1.3.1 概念

**1.晶体管(transistor)**

晶体管:一种由电信号控制的简单开关.

**2.集成电路(IC:ingerated circuit)**

集成电路:由成千上万个晶体管组成的芯片.

**3.超大规模集成电路(VLSI:very large-scale integrated circuit)**

超大规模集成电路:由数十万到数百万晶体管组成的电路.

#### 1.3.2 芯片制造

用化学方法对硅添加某些材料,是硅的某些区域转变为:

	1.良好的导电体(类似细微的铜线或铝线);
	2.良好的绝缘体(类似塑料或玻璃膜);
	3.可控的导电体或绝缘体(类似开关).

制造流程:

![](images/flow_of_chip_manufacturing.png)

硅锭/晶圆/Die/Socket:

	1.硅锭(silicon crystal ingot):一块由硅晶体组成的棒.直径约8-12英寸,长度约12-24英寸;
	2.晶圆(wafer):厚度不超过0.1英寸的硅锭片,用来制造芯片;
	3.Die:从晶圆(wafer)上切割下来的一个个的小方块(方形的原因是便于切割),并在该Die上面将逻辑电路刻在
		上面构成真正的Die.如果Die的面积足够小,wafer的利用率可以接近于100%;
	4.Socket:将1个或N个CPU Die封装起来形成一个CPU Package,也叫CPU Socket;
	PS:Die的大小越大,CPU Die出错的概率越高,良品率也越低,成本相应就越高.

Intel和AMD芯片区别:

	1.Intel Xeon系列(服务器芯片)将整个CPU Socket做到一个CPU Die上.优点是:CP内部直接各组件的连接是片内
		总线互联,有更多资源共享(e.g.所有的CPU内核共享L3),整体的性能更高;缺点是成本大,价格高.
	2.AMD EYPC CPU每个CPU Socket有4个CPU Die,每个CPU Die包含4个CPU 内核.CPU Die之间通过片外总线
		(Infinity Fabric)互联,不同Die上的CPU内核不能共享CPU Cache.这种分布导致虽然单Core与Intel差不
		多,性能却赶不上Intel Xeon处理器.但是好处是便宜.

### 1.4 性能

#### 1.4.1 性能度量

**1.个人计算机与数据中心的区别**

个人计算机关心的是响应时间(response time),数据中心关心的是吞吐率(throughout).

	响应时间:也叫执行时间(execution time),是计算机完成某任务所需的总时间(包括硬盘访问、内存访问、IO
		活动、操作系统开销和CPU执行时间等);
	吞吐率:也叫带宽(bandwidth),表示单位时间内完成的任务数量.

**2.CPU时钟周期(clock cycle)和时钟频率(clock rate)**

	CPU时钟周期为250ps,对应的CPU时钟频率为4GHz.

#### 1.4.2 CPU的性能

CPU的性能度量方法是:一个程序的CPU执行时间,执行时间越短,CPU的性能越好;反之越差.

一个程序的CPU执行时间公式:

	1.一个程序的CPU执行时间 = 一个程序的CPU时钟周期数 x CPU的时钟周期
	2.一个程序的CPU执行时间 = 一个程序的CPU时钟周期数 / CPU的时钟频率

实例:

	某程序在一台时钟频率为2GHz的计算机A上运行需10s.在B上通过提高时钟频率,希望运行时间缩短为6s,但是周期数
	会提升为A的1.2倍.求B的时钟频率提高到多少?
		1.程序在A上运行的时间 = 周期数 / 频率
			即:10s = 周期数 / 2GHz	=> 周期数 = 10s * 2GHz
		2.程序在B上运行的时间 = 周期数 / 频率
			即:6s = 1.2周期数 / f	=> f = (1.2 * 10s * 2G) / 6s = 4GHz
		因此:B的时钟频率需要提高为A的2倍.

#### 1.4.3 指令的性能

	1.一个程序的CPU时钟周期数 = 程序的指令数 x 每条指令的平均时钟周期数(即CPI);
	2.CPI(clock cycle per instruction):一个程序全部指令所用时钟周期数的平均值.

实例:

	一个程序使用相同指令集.在时钟周期为250ps的A计算机上的CPI为2.0;而在时钟周期为500ps的B计算机上的CPI
		为1.2.求哪台计算机的速度更快?
	1.程序在A上的运行时间 = 周期数 * 周期; 而:周期数 = I(指令数) * CPI
		因此: 在A上运行时间 = I * 2.0 * 250ps = 500I
	2.程序在B上的运行时间 = 周期数 * 周期; 而:周期数 = I(指令数) * CPI
		因此: 在B上运行时间 = I * 1.2 * 500ps = 600I
	因此:对该程序A是B的1.2倍.

#### 1.4.4 经典的CPU性能公式

	1.CPU时间 = 指令数 x CPI X CPU时钟周期
	2.CPU时间 = 指令数 x CPI / CPU时钟频率

有时候也用IPC来代替CPI:

	IPC(instruction per clock cyle):表示每个时钟周期可执行的指令数,为CPI的倒数.

### 1.5 衡量CPU的基准

#### 1.5.1 SPEC CPU基准测试程序

1.benchmark

基准测试程序,用于比较计算机性能的程序.

2.SPECint2006--->最新的为SPECint2017

整数基准程序集.描述为:

![](images/spec2006_description.png)

3.SPECfp2006

浮点基准程序集.

#### 1.5.2 SPEC功耗基准测试程序

SPECpower

评估功耗的基准测试程序.

***

## Chapter 2 指令:计算机的语言

指令集:一个给定的计算机体系结构所包含的指令集和.

### 2.1 计算机硬件的操作

字:计算机中的基本访问单位,通常是32-bit(x86的word是16-bit).

```
寄存器个数限制原因:寄存器多时可能会使时钟周期变长,因为电信号传输更远的距离必然花费更长的时间.
```

#### 2.1.1 存储操作数

MIPS的算数运算指令只对寄存器进行操作(ARM也是一样).因此,MIPS包含在储存器和寄存器之间传送数据的指令,叫做数据传送指令(data transfer instruction).

```
数据传送指令(load/store):在储存器和寄存器之间移动数据的命令.
	ldr x0, =0x81000000		// 此处将值0x81000000(是一个地址)放到x0寄存器中
	ldr x1, =0x0060000000000001	// 此处将值0x0060000000000001(是一个数据)放到x0寄存器中
	str x1, [x0, 0x00]		//  此处将x1寄存器中的内容储存到x0寄存器中的内容(为一个地址)偏移0x00所表示地址中.
PS:ldr和str都是寄存器在前,数据信息在后.
因此:
	1.ldr:将数据(数据可能直接能获取(e.g.ldr x0, =0x81000000)或者从地址中获取(ldr x1, [x0],从x0寄存器中的内容(是一个地址)中获取数据))搬移到寄存器中;
	2.str:(str x1, [x0])将寄存器中x1的内容(放的一个值)存到x0寄存器的内容(x0寄存器的内容是一个地址)所表示的地址中去.
```

PS:许多程序的变量个数要远多于计算机的存储器个数.因此,编译器会尽量将最常用的变量保持在寄存器中,而将其他的变量放在存储器中,方法是使用ldr/str指令在寄存器和存储器之间传送变量.

```
1.将不常用的变量(或稍后才使用的变量)存回到存储器的过程叫寄存器溢出(spilling);
2.寄存器与存储器相比:访问时间短、吞吐率高,寄存器中的数据访问速度快并易于利用,且功耗更小.
```

#### 2.1.2 常数或立即数操作数

使用常数前必须先将其从存储器中取出(常数可能在程序被加载时放入存储器的).

PS:MIPS寄存器也分为32-bit和64-bit,分别称为MIPS-32和MIPS-64,ARM应该就是借鉴MIPS的命名规则来的.

### 2.2 有符号数和无符号数

```
LSB(least significant bit):最低有效位,在字中最右边的1 bit;
MSB(most significant bit):最高有效位,在字中最左边的1 bit.
```

计算机中有符号数的表示方法:

```
1.正数:MSB为0的表示正数,直接表示即可;
2.负数:MSB为1的表示负数,用补码表示.
	1.负的二进制数计算出相应的十进制数:
        1111 1111 1111 1111 1111 1111 1111 1100
        --->表示的负数为:
        1.取反:
            0000 0000 0000 0000 0000 0000 0000 0011
        2.+1:
            0000 0000 0000 0000 0000 0000 0000 0100
        3.最后表示的负数为:
            -4
	2.负的十进制数转换为相应的二进制数:
		1.十进制数:
			-2
		2.2的十进制数的表示:
			0000 0000 0000 0000 0000 0000 0000 0010
		3.取反:
			1111 1111 1111 1111 1111 1111 1111 1101
		4.+1:
			1111 1111 1111 1111 1111 1111 1111 1110
		5.最后的二进制数即为:
			1111 1111 1111 1111 1111 1111 1111 1110
3.正数最大的数:
	0111 1111 1111 1111 1111 1111 1111 1111--->即最大的正数为:2^31-1;
4.负数最大的数:
	1000 0000 0000 0000 0000 0000 0000 0000--->即最大的负数为:-2^31.
```

### 2.3 计算机中指令的表示

计算机中几乎所有的指令都要用到寄存器.

```
1.MIPS的指令长度是32-bit;ARM的指令长度也是32-bit;
2.把指令的数字形式称为机器语言(也叫机器指令),这样组成的指令序列叫做机器码.
```

#### 2.3.1 MIPS的指令解析

MIPS的指令解析(机器指令的解析)---->总共32-bit:

| op(6-bit) | rs(5-bit) | rt(5-bit) | rd(5-bit) | shamt(5-bit) | funct(6-bit) |
| --------- | --------- | --------- | --------- | ------------ | ------------ |

```
op:指令的操作码(opcode),用来表示操作和格式的字段;
rs:第一个源操作数寄存器;
rt:第二个源操作数寄存器;
rd:存放操作结果的目的寄存器;
shamt:位移量(仅用于移位指令);
funct:功能码(function code),用于指明op字段中操作的特定变式.
```

#### 2.3.2 MIPS的指令解析实例

```
// 反汇编码
8000021c:	8d2a0000 	lw	t2,0(t1)
1.第1个域段表示地址信息,每条指令存放的地址,4Byte递增(因为指令是32-bit);
2.第2个域段表示指令码,解析如下:
	op(高6-bit):8d右移2bit得到35--->表示lw;
	其他bit暂略--->没解析出来.
3.第3个域段表示汇编代码,表示load word操作.
```

#### 2.3.3 寄存器数量规则

寄存器的数量的选取是有规则的:

```
寄存器数量的增长就需要在指令格式的各个寄存器字段中至少增加1-bit,因此综合考虑.当前的大多数指令系统中的通用寄存器为16/32个.
```

### 2.4 逻辑操作

对bit进行操作称为逻辑操作.

```
按位与:按bit进行与操作,仅当两个bit均为1时结果才是1;
按位或:按bit进行或操作,当两个bit中任意一位为1时结果就为1;
按位取反:按bit进行取非操作,只需要一个bit,即将1变为0,0变为1;
或非:按bit先或后非操作,两个bit或后得到一个bit,之后再对这一个bit进行取反;
异或(XOR):当两个bit不同时结果是1,相同时结果为0.
```

### 2.5 计算机硬件对过程的支持

过程:根据提供的参数执行一定任务的存储的子程序.

#### 2.5.1 过程支持的必要信息

```
跳转和链接指令:跳转到某个地址的同时将下一条指令的地址保存到寄存器中的指令(e.g. MIPS保存到$ra寄存器);
返回地址:指向调用点的链接,使过程可以返回到合适的地址(在MIPS中它存储在寄存器$ra中);
程序计数器(PC):一个寄存器包含正在被执行指令的地址.
```

#### 2.5.2 栈

栈:具有后进先出的特点,用于寄存器换出的数据结构.

```
栈指针:指示寄存器被换出的位置,在MIPS中栈指针是寄存器$SP;
入栈:向栈中增加元素;
出栈:从栈中移除远处;
栈增长:一般栈增长是按照地址从高到低增长,所以入栈时,栈指针是减小的;出栈时,栈指针变大.
```

### 2.6 人机交互

在C语言中,用一个值0(ASCII码中的null)的字节来结束字符串.

```
字符串"Cal"在C中用4字节表示,分别是十进制的:67,97,108,0(结尾的0).
```

实例:

```
// 将null接为的字符串y复制到字符串x
void strcpy(char x[], char y[])
{
	int i = 0;
	while ((x[i] = y[i]) != '\0') {	// 赋值y[i]到x[i],并判断是否为'\0'(结束字符,数字0的字符表示为'\0')
		i += 1;
	}
}
```

数字0的各种表示:

```
1.数字表示:0;
2.指针表示:null;
3.字符表示:'\0'
```

 PS:当今的大部分web页面采用Unicode编码,而不是ASCII编码.

```
在SPEC基准测试程序中,大概一半条件分支的跳转距离小于16条指令.
```

### 2.7 翻译并执行程序

#### 2.7.1 编译器

编译器:将C程序编译成一种机器能理解的符号形式的汇编语言程序.

#### 2.7.2 汇编器

汇编器:将汇编语言程序汇编成目标文件.

Unix/Linux的目标文件通常包含以下6部分:

```
1.目标文件头:描述目标文件其他部分的大小和位置;
2.代码段:包含机器语言代码;
3.静态数据段:包含在程序生命周期内一直存在的数据;
4.重定位信息:标记了一些在程序加载进内存时依赖于绝对地址的指令和数据;
5.符号表:包含未定义的剩余标记(e.g. 外部引用);
6.调试信息:包含一份说明目标模块如何编译的简明描述,这样调试器能够将机器指令关联到C源文件,并使数据结构也变得可读.
```

#### 2.7.3 链接器

链接器:一个系统程序,把各个独立汇编的机器语言程序组合起来并解决所有未定义的标记,最后生成可执行程序.

#### 2.7.4 加载器

加载器:把目标程序加载到内存中以准备运行的系统程序.

加载器(loader)的工作步骤如下:

```
1.读取可执行文件头来确定代码段和数据段的大小;
2.为正文和数据创建一个足够大的地址空间;
3.将可执行文件中的指令和数据复制到内存中;
4.把主程序的参数(如果存在)复制到栈顶;
5.初始化机器寄存器,将栈指针指向第一个空位置;
6.跳转到启动例程,将参数复制到参数寄存器并且调用程序的main函数.当main函数返回时,启动例程通过系统调用exit终止程序.
```

#### 2.7.5 动态链接库

动态链接库:在程序执行过程中才被链接的例程库.

## Chapter 3 计算机的算数运算



## Chapter n: 常用的队列调度算法

常用的队列调度算法为:SP(strict priority,严格优先级),RR(Round Robin,循环调度),WRR(Weighted Round Robin,加权循环调度算法).

### n.1 SP调度

SP:对不同的队列设置不同的优先级,高优先级的会优先出队,只有高优先级的全部出队后,低优先级的才会出队.

	优点:配置简单,绝对保证高优先级的带宽;
	缺点:低优先级的可能会被饿死,不公平.
	PS:一般会设置防饿死机制.

### n.2 RR调度

依次调度各队列的数据包,绝对公平的调度算法.

	优点:绝对公平;
	缺点:分不清轻重急缓,高优先级的得不到优点调度.

### n.3 WRR调度

WRR:为每个队列设置一个count,根据权重weight机型初始化.每次轮询一个队列,该队列输出一个报文,且count减1.当count为0时停止调度该队列,继续调度不为0的队列.当所有的队列的count都为0时,重新初始化count,开始新一轮的调度.

![](images/wrr_scheduler1.png)

![](images/wrr_scheduler2.png)

![](images/wrr_scheduler3.png)