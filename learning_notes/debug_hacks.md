# Debug Hacks

# 4. 获取进程的内核转储

## 4.1 内核转储概念

内核转储(core dump):保存问题发生时的状态.只要bug出现时存在程序的可执行文件和内核转储,就可以知道进程当前的状态.

```
在不清楚bug复现方法的情况下,或是bug及其罕见,又或是只在特定的机器上发生的情况等.此时只要获取到core dump,即使手头上没有复现环境,也能进行debug.
```

## 4.2 linux内核启用内核转储

### 4.2.1 查看linux的内核转储功能是否有效

```
ulimit -c	//-c选项表示内核转储文件的大小限制.默认输出0,表示内核转储无效.大多数linux发行版默认情况下关闭了内核转储功能.
```

### 4.2.2 开启内核转储

下面方法设置内核转储文件的大小为无限制.发生问题时进程的内存就可以全部转储到内核转储文件中去.

```
ulimit -c unlimited	//设置内核转储文件的大小为无限制.
```

某些进程会大量消耗系统内存,设置为无限制会导致系统崩溃.此时可以设置内核转储文件的上限,方法如下:

```
ulimit -c 1073741824	//设置内核转储文件的上限为1GB.
```

### 4.2.3 实例

#### 4.2.3.1 源代码

```
// debug_test.c
#include <stdio.h>

int main()
{
	int *a = NULL;
	*a = 0x1;	//给NULL指针赋值
	return 0;
}
```

#### 4.2.3.2 编译

```
gcc -g debug_test.c -o debug_test	/* -g需要加在前面,加在其他位置编译错误 */
```

#### 4.2.3.3 开启内核转储并设置最大容量1GB

```
ulimit -c 1073741824
ulimit -c	//查看设置结果,显示"1073741824".
```

#### 4.2.3.4 运行有bug的程序

```
./debug_test
/*
	显示为:Segmentation fault (core dumped)
	并在当前目录下生成内核转储文件:"core"文件.
*/
查看生成的core文件的类型:
file core
/*
	结果为:core: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from './debug_test'
*/
```

#### 4.2.3.5 使用gdb调试生成的内核转储文件

```
gdb -c core ./debug_test
/*
    GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
    Copyright (C) 2016 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
    and "show warranty" for details.
    This GDB was configured as "x86_64-linux-gnu".
    Type "show configuration" for configuration details.
    For bug reporting instructions, please see:
    <http://www.gnu.org/software/gdb/bugs/>.
    Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.
    For help, type "help".
    Type "apropos word" to search for commands related to "word"...
    Reading symbols from ./debug_test...done.
    [New LWP 14624]
    Core was generated by `./debug_test'.
    Program terminated with signal SIGSEGV, Segmentation fault.
    #0  0x00000000004004e6 in main () at debug_test.c:6
    6		*a = 0x1;
   (gdb) l
    1	#include <stdio.h>
    2	
    3	int main()
    4	{
    5		int *a = NULL;
    6		*a = 0x1;	//挂在该行了
    7		return 0;
    8	}
*/
//会直接跑到挂的位置.没有重新运行程序,比gdb重新运行程序效率高,gdb运行程序需要重跑.
```

其他暂略.

# 5. GDB的基本用法1

## 5.1 编译选项的选择

要使用gdb调试程序,编译时必须带上-g选项.

```
1.简单的编译文件
gcc -Wall -O2 -g 源文件
2.Makefile构建编译,需要在CFLAGS中指定-g选项
CFLAGS = -Wall -O2 -g
3.如果是configure脚本生成Makefile
./configure CFLAGS="-Wall -O2 -g"
```

优化选项的说明:

```
-O0:无优化(默认);
-O和-O1:能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化
	在编译大型程序时会显著增加编译时内存的使用和时间.
-O2:增加编译时间和提高目标文件的执行性能
	1.-O2包含了-O1的优化并增加了不需要在目标文件大小和执行速度上进行折中的优化;
	2.-O2选项不执行循环展开和函数内联的展开.
-Os:专门优化目标文件大小
	1.-Os执行所有的不增加目标文件大小的-O2优化选项;
	2.执行专门减小目标文件大小的优化选项.
-O3:打开所有-O2的优化选项,并且增加:
	1.-finline-functions--->内联函数展开;
		内联函数展开,此时就不能在该函数名上设置断点.因为展开后会从目标文件中去掉该函数的入口点,最后的符号表中没有该函数的名称.
	2.-funswitch-loops--->循环展开;
	3.-fpredictive-commoning,-fgcse-after-reload and -ftree-vectorize等.
```

优化选项打开后,局部变量会被保存到寄存器中,此时用gdb无法显示局部变量的内容,必须直接查看寄存器的值.

PS:测试和调试代码的正确方法应该是调试带有优化选项的代码,而不是去掉优化选项重新编译并运行.

## 5.2 启动gdb

gdb+可执行文件即可.

```
有时候需要携带参数,可以使用如下方法:
	gdb --args 可执行文件 参数...
```

## 5.3 gdb的使用

### 5.3.1 设置断点

#### 5.3.1.1 设置断点

```
b 函数名	// 不存在同名的函数可以使用这种方法(b是break的缩写)
b 文件名:行号	// 这种用的比较多
b 文件名:函数名
b +offset	// 在暂停位置往后offset行下断点
b -offset	// 在暂停位置往前offset行下断点
```

#### 5.3.1.2 查看断点

```
info b
```

### 5.3.2 运行

直接执行run(简写r),即可执行到设置了断点的位置后暂停.

```
// 如果是想程序运行到main()函数处断下来,可以在gdb中直接敲入:
start	// 此时不需要在main()函数下断点后再断下来,start会自动运行到main()函数处断下来.
```

### 5.3.3 显示栈帧

程序运行过程中遇到断点而暂停,可以通过输入"bt"(backtrace)显示栈帧.

```
bt	//遇到断点输入"bt"显示栈帧
/*
	bt还有其他的别名:where, info stach或者info s,效果和bt是一样的.
*/
bt 3 // 只显示前3个栈帧
bt -3 // 只显示最后3个栈帧
bt full	// 不仅显示backtrace,还显示局部变量.即显示的东西更丰富
```

### 5.3.4 显示变量

print命令用于显示变量的信息,可以简写为"p".

```
p var
p /x var	//显示为十六进制数
p /d var	//显示为十进制数
p /u var	//显示为无符号十进制数
p /o var	//显示为八进制数
p /t var	//显示为二进制数,t的由来是two
p /a var	//显示地址
p /c var	//显示为字符(ASCII)
p /f var	//显示为浮点小数
p /s var	//显示为字符串
```

### 5.3.5 显示寄存器

info register可以显示寄存器,简写为"info reg".

```
(gdb) info reg
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7fffffffe4c8	140737488348360
rsi            0x7fffffffe4b8	140737488348344
rdi            0x1	1
rbp            0x7fffffffe3d0	0x7fffffffe3d0
rsp            0x7fffffffe3d0	0x7fffffffe3d0
r8             0x400570	4195696
r9             0x7ffff7de7af0	140737351940848
r10            0x846	2118
r11            0x7ffff7a2d750	140737348032336
r12            0x4003e0	4195296
r13            0x7fffffffe4b0	140737488348336
...
p $rax	// 在寄存器名前面添加"$",可以显示寄存器的内容
4195542	// 输出寄存器中的内容
```

### 5.3.6 显示内存内容

x命令可以显示内存的内容,x的由来是:eXamining.

```
x /x addr	//以十六进制显示addr里的内容(p中其他显示格式x也支持)
x /i $pc	//显示pc指向地址的汇编指令

(gdb) x /10i $pc	//显示pc位置开始的10条汇编指令
=> 0x4004da <main+4>:	movq   $0x0,-0x8(%rbp)
   0x4004e2 <main+12>:	mov    -0x8(%rbp),%rax
   0x4004e6 <main+16>:	movl   $0x1,(%rax)
   0x4004ec <main+22>:	mov    $0x0,%eax
   0x4004f1 <main+27>:	pop    %rbp
   0x4004f2 <main+28>:	retq   
   0x4004f3:	nopw   %cs:0x0(%rax,%rax,1)
   0x4004fd:	nopl   (%rax)
   0x400500 <__libc_csu_init>:	push   %r15
   0x400502 <__libc_csu_init+2>:	push   %r14
```

### 5.3.7 显示反汇编内容

显示反汇编内容的命令是:disassemble,简写为:disas.

```
disas	//直接显示pc指针前后的几条反汇编指令
disas $pc	//显示pc指针前后的几条反汇编指令

(gdb) disas $pc
Dump of assembler code for function main:
   0x00000000004004d6 <+0>:	push   %rbp
   0x00000000004004d7 <+1>:	mov    %rsp,%rbp
=> 0x00000000004004da <+4>:	movq   $0x0,-0x8(%rbp)	--->pc指向的位置
   0x00000000004004e2 <+12>:	mov    -0x8(%rbp),%rax
   0x00000000004004e6 <+16>:	movl   $0x1,(%rax)
   0x00000000004004ec <+22>:	mov    $0x0,%eax
   0x00000000004004f1 <+27>:	pop    %rbp
   0x00000000004004f2 <+28>:	retq   
End of assembler dump.
```

### 5.3.8 单步执行

单步执行的命令如下:

```
next(简写n):单步执行,不会进入到函数内部;
step(简写s):单步执行,会进入函数内部;
ni(next instruction):逐条执行汇编指令,不会进入到函数内部;
si(step instruction):逐条执行汇编指令,会进入到函数内部.
```

### 5.3.9 继续执行

继续执行命令如下:

```
c(continue):继续执行,直到遇到断点暂停或运行到程序结束;
c 5:5次遇到断点不停止,直到第6次遇到断点才暂停执行.适合调试循环程序.
```

### 5.3.10 监视变量

watch命令用于监视某个变量,确定变量在何处被改变.

```
watch var	// var发生变化时暂停运行;
awatch var	// var被访问或改变时暂停运行;
rwatch var	// var被访问时暂停运行.
```

PS:设置监视点可能会降低程序运行速度.

### 5.3.11 删除断点或监视点

d(delete)用于删除断点或监视点.

```
info b	// 查看断点
d 2		// 删除2号断点
dis 3	// disable 3号断点,让程序不在3号断点断下.
ena 3	// enable 3号断点,使能3号断点
```

### 5.3.12 改变变量的值

下面的命令用于改变变量的值:

```
set variable var=val	// 将变量var的值更改为val

p options	// 结果为7
set variable options = 0	// 将变量options更改为0
p options	// 结果为0
```

PS:改功能可以在运行时随意修改变量的值.

# 6. GDB的基本用法2



















































