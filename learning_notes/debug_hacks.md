# Debug Hacks

# 4. 获取进程的内核转储

## 4.1 内核转储概念

内核转储(core dump):保存问题发生时的状态.只要bug出现时存在程序的可执行文件和内核转储,就可以知道进程当前的状态.

```
在不清楚bug复现方法的情况下,或是bug及其罕见,又或是只在特定的机器上发生的情况等.此时只要获取到core dump,即使手头上没有复现环境,也能进行debug.
```

## 4.2 linux内核启用内核转储

### 4.2.1 查看linux的内核转储功能是否有效

```
ulimit -c	//-c选项表示内核转储文件的大小限制.默认输出0,表示内核转储无效.大多数linux发行版默认情况下关闭了内核转储功能.
```

### 4.2.2 开启内核转储

下面方法设置内核转储文件的大小为无限制.发生问题时进程的内存就可以全部转储到内核转储文件中去.

```
ulimit -c unlimited	//设置内核转储文件的大小为无限制.
```

某些进程会大量消耗系统内存,设置为无限制会导致系统崩溃.此时可以设置内核转储文件的上限,方法如下:

```
ulimit -c 1073741824	//设置内核转储文件的上限为1GB.
```

### 4.2.3 实例

#### 4.2.3.1 源代码

```
// debug_test.c
#include <stdio.h>

int main()
{
	int *a = NULL;
	*a = 0x1;	//给NULL指针赋值
	return 0;
}
```

#### 4.2.3.2 编译

```
gcc -g debug_test.c -o debug_test	/* -g需要加在前面,加在其他位置编译错误 */
```

#### 4.2.3.3 开启内核转储并设置最大容量1GB

```
ulimit -c 1073741824
ulimit -c	//查看设置结果,显示"1073741824".
```

#### 4.2.3.4 运行有bug的程序

```
./debug_test
/*
	显示为:Segmentation fault (core dumped)
	并在当前目录下生成内核转储文件:"core"文件.
*/
查看生成的core文件的类型:
file core
/*
	结果为:core: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from './debug_test'
*/
```

#### 4.2.3.5 使用gdb调试生成的内核转储文件

```
gdb -c core ./debug_test
/*
    GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
    Copyright (C) 2016 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
    and "show warranty" for details.
    This GDB was configured as "x86_64-linux-gnu".
    Type "show configuration" for configuration details.
    For bug reporting instructions, please see:
    <http://www.gnu.org/software/gdb/bugs/>.
    Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.
    For help, type "help".
    Type "apropos word" to search for commands related to "word"...
    Reading symbols from ./debug_test...done.
    [New LWP 14624]
    Core was generated by `./debug_test'.
    Program terminated with signal SIGSEGV, Segmentation fault.
    #0  0x00000000004004e6 in main () at debug_test.c:6
    6		*a = 0x1;
   (gdb) l
    1	#include <stdio.h>
    2	
    3	int main()
    4	{
    5		int *a = NULL;
    6		*a = 0x1;	//挂在该行了
    7		return 0;
    8	}
*/
//会直接跑到挂的位置.没有重新运行程序,比gdb重新运行程序效率高,gdb运行程序需要重跑.
```

其他暂略.

# 5.GDB的基本用法1

## 5.1 编译选项的选择

要使用gdb调试程序,编译时必须带上-g选项.

```
1.简单的编译文件
gcc -Wall -O2 -g 源文件
2.Makefile构建编译,需要在CFLAGS中指定-g选项
CFLAGS = -Wall -O2 -g
3.如果是configure脚本生成Makefile
./configure CFLAGS="-Wall -O2 -g"
```

优化选项的说明:

```
-O0:无优化(默认);
-O和-O1:能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化
	在编译大型程序时会显著增加编译时内存的使用和时间.
-O2:增加编译时间和提高目标文件的执行性能
	1.-O2包含了-O1的优化并增加了不需要在目标文件大小和执行速度上进行折中的优化;
	2.-O2选项不执行循环展开和函数内联的展开.
-Os:专门优化目标文件大小
	1.-Os执行所有的不增加目标文件大小的-O2优化选项;
	2.执行专门减小目标文件大小的优化选项.
-O3:打开所有-O2的优化选项,并且增加:
	1.-finline-functions--->内联函数展开;
		内联函数展开,此时就不能在该函数名上设置断点.因为展开后会从目标文件中去掉该函数的入口点,最后的符号表中没有该函数的名称.
	2.-funswitch-loops--->循环展开;
	3.-fpredictive-commoning,-fgcse-after-reload and -ftree-vectorize等.
```

优化选项打开后,局部变量会被保存到寄存器中,此时用gdb无法显示局部变量的内容,必须直接查看寄存器的值.

PS:测试和调试代码的正确方法应该是调试带有优化选项的代码,而不是去掉优化选项重新编译并运行.























