# Assembly Instructions

板子的启动流程:

	----------------------------------------------------------------
		step 1				Bootrom		
		1)固化在硬件中,一上电就跳到Bootrom执行
		2)在板子的rom空间中执行,rom可以直接执行代码
		3)初始化CPU的SRAM(准备loader Auxcode)
	----------------------------------------------------------------
		step 2				Auxcode
		1)初始化DDR
		2)引导bootloader
		3)在CPU的SRAM中执行
	----------------------------------------------------------------
		step 3				bootloader
		1)引导kernel(或其他OS)
		2)在DDR中执行
	----------------------------------------------------------------
# 1. ARM汇编指令

## Auxcode中的boot.S---适配Cortex A7(CA7)

	#define SP_MAX_SIZE		(1024*5)	/*堆大小为5K*/
	#define MONITOR_SP		(1024*1)	/*monitor 堆大小为1K*/

		.globl	sm_vect_table	/*.globl/.global symbol:声明后面的symbol(sm_vect_table)是全局可见的.*/
								/*.global:使得连接程序(ld)能够识别symbol.也即外部程序可以访问的标签*/
		.func sm_vect_table		/*声明一个函数???*/
	------------------------------------------------------------------------------------------------------
	sm_vect_table:		/*格式"symbol:"仅仅表示一个标号.此处表示sm的向量表,该表由arm硬件架构已经定义好的.*/
		b	_start		/*(reset)芯片reset时的处理,第一条指令.此处表示跳转到标号"_start"处执行*/
		b	.			/*(undefined instruction)未定义指令异常的处理.此处"."表示死循环,跳到自身位置*/
		b	sm_smc_entry	/*(secure monitor call)调用的处理.此处表示跳转到标号"sm_smc_entry"处执行*/
		b	.			/*(Prefetch abort)取指异常的处理.此处"."表示死循环,跳到自身位置*/
		b	.			/*(Data abort)数据访问异常的处理.此处"."表示死循环,跳到自身位置*/
		b	.			/*(Reserved)保留,其他异常的处理.此处"."表示死循环,跳到自身位置*/
		b	.			/*(IRQ)中断处理.此处"."表示死循环,跳到自身位置*/
		b	.			/*(FIQ)快中断处理.此处"."表示死循环,跳到自身位置*/
		.endfunc		/*函数结束???*/

	/*向量表反汇编:
	80000000 <sm_vect_table>:	//标号.8000_0000是在链接时指定的
	<物理地址>	<机器码>	  <指令>	<跳转到的地址><标号助记符>
	80000000:	ea000006 	b	80000020 <_start>	<reset指令,此时跳转到20的位置>
	80000004:	eafffffe 	b	80000004 <sm_vect_table+0x4>	<跳转到自身,表示死循环>
	80000008:	ea000039 	b	800000f4 <sm_smc_entry>	<secure monitor call,此时跳转到f4的位置>
	8000000c:	eafffffe 	b	8000000c <sm_vect_table+0xc>	<跳转到自身,表示死循环>
	80000010:	eafffffe 	b	80000010 <sm_vect_table+0x10>	<跳转到自身,表示死循环>
	80000014:	eafffffe 	b	80000014 <sm_vect_table+0x14>	<跳转到自身,表示死循环>
	80000018:	eafffffe 	b	80000018 <sm_vect_table+0x18>	<跳转到自身,表示死循环>
	8000001c:	eafffffe 	b	8000001c <sm_vect_table+0x1c>	<跳转到自身,表示死循环>
	*/
	------------------------------------------------------------------------------------------------------
	.globl _start	/*标号"_start":是GNU链接器用来指定第一个要执行的指令所必须的,全局可见(并且只能出现在一个模块中).*/
	_start:
		mrc p15, 0, r0, c0, c0, 5	/*mrc:读取协处理器中的寄存器数据到ARM处理器的寄存器中.
										mcr:用于读取ARM处理器的寄存器数据到协处理器的寄存器中.*/
		/*
			p15:协处理器p15.CP15协处理器用于系统存储管理.
			0:协处理器将执行的操作的操作码.对于CP15来说,该操作码永远是"0".
			r0:ARM寄存器.mrc时将作为目标寄存器
			第一个c0:协处理器寄存器.协处理器cp15的c0寄存器存放的是CPU的ID号.
			第二个c0:协处理器的附加寄存器.如果不需要附加信息,则指定为"c0".
			5:操作类型(第二个数(操作码)的附加参数).此处表示类型5.
			该条汇编指令的意思:读取ARM CPU的ID号(处理器版本号)到ARM寄存器r0里面.
		*/
		and r0, r0, #0x3	/*r0 = r0 & 0x3--->[1:0]CPU的ID位.提取ID位,表示几号CPU.*/
		cmp r0, #0			/*比较r0和0是否相等.确定是否是0号CPU*/
		bne run_secondary	/*如果上述的cmp不相等,跳转到"run_secondary"去执行*/
		b   init_start		/*否则就跳转到"init_start"执行*/

	/*反汇编该段代码:
	80000020 <_start>:
	80000020:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
	80000024:	e2000003 	and	r0, r0, #3
	80000028:	e3500000 	cmp	r0, #0
	8000002c:	1a000000 	bne	80000034 <run_secondary>
	80000030:	ea000001 	b	8000003c <init_start>
	*/
	------------------------------------------------------------------------------------------------------
	run_secondary:
		wfi		/*wfi:wait for interrupt.让ARM核进入low-power standby模式.*/
		b run_secondary		/*死循环*/
	/*反汇编:
	80000034 <run_secondary>:
	80000034:	e320f003 	wfi
	80000038:	eafffffd 	b	80000034 <run_secondary>
	*/
	------------------------------------------------------------------------------------------------------
	init_start:
		bl disable_mmu	/*bl:带链接的跳转,常用于调用子程序,返回地址自动保存在lr中; b:无条件跳转到标号,无返回.*/
		bl disable_l1_cache			/*disable L1 cache*/
		bl invalidate_l1_icache		/*invalidate L1 icache, tlb, bp array*/

	------------------------------------------------------------------------------------------------------
	disable_mmu:
		dsb		/*数据同步屏障,只有完成:1.位于此指令前的所有显式内存访问均完成;2.位于此指令前的所有缓存、跳转预测
				和TLB维护操作全部完成.此指令才会完成.后面可带参数:SY(完整的系统DSB操作),因为是缺省情况,可省略.*/
		mrc p15, 0, r2, c1, c0, 0	/*mrc:读取协处理器中的寄存器数据到ARM处理器的寄存器中.
										mcr:用于读取ARM处理器的寄存器数据到协处理器的寄存器中.*/
		/*
			p15:协处理器p15.CP15协处理器用于系统存储管理.
			0:协处理器将执行的操作的操作码.对于CP15来说,该操作码永远是"0".
			r2:ARM寄存器.mrc时将作为目标寄存器
			第一个c1:协处理器寄存器.协处理器cp15的c1寄存器是一个控制寄存器,其功能包括:
				禁止或使能MMU以及其他与存储系统相关的功能;
				配置存储系统以及ARM处理器中的相关部分工作.
			第二个c0:协处理器的附加寄存器.如果不需要附加信息,则指定为"c0".
			0:操作类型(第二个数(操作码)的附加参数).此处表示类型0.
			该条汇编指令的意思:读取ARM CPU的MMU中的控制位值到ARM寄存器r2里面.
		*/
		bic r2, r2, #0x1	/*后一个r2与"#"立即数0x1的反码取与,然后写入到第一个r2中.实现"位清除",即r2[0]=0.
							cp15中的c1[0]=0->disable MMU; c1[0]=1->enable MMU.*/
		mcr p15, 0, r2, c1, c0, 0	/*将清掉[0]=0的r2寄存器的值写入到协处理器p15的c1寄存器.
									实现disable MMU*/
		isb		/*确保在ISB指令完成后,才从高速缓存或内存中提取位于该指令后的其他所有指令.默认值为SY,完成的系统DMB操作.*/
		bx lr	/*bx:带状态切换的跳转指令.此处为返回到调用处.*/
		/*反汇编该段代码:
		800004d8 <disable_mmu>:
		800004d8:	f57ff04f 	dsb	sy
		800004dc:	ee112f10 	mrc	15, 0, r2, cr1, cr0, {0}
		800004e0:	e3c22001 	bic	r2, r2, #1
		800004e4:	ee012f10 	mcr	15, 0, r2, cr1, cr0, {0}
		800004e8:	f57ff06f 	isb	sy
		800004ec:	e12fff1e 	bx	lr
		*/
	------------------------------------------------------------------------------------------------------
	disable_l1_cache:
		mrc p15, 0, r2, c1, c0, 0
		bic r2, r2, #(0x1 << 12)	/*协处理器p15的c1寄存器的[12]=0->disalbe I cache; 
									[12]=1->enable I cache.此处为disable I cache.*/
		bic r2, r2, #(0x1 << 2)		/*协处理器p15的c1寄存器的[2]=0->disalbe D cache; 
									[2]=1->enable D cache.此处为disable D cache.*/
		mcr p15, 0, r2, c1, c0, 0	/*将清掉[2]和[12]的r2寄存器的值写入到协处理器p15的c1寄存器*/
		bx lr	/*bx:带状态切换的跳转指令.此处为返回到调用处.*/
		/*反汇编该段代码:
		800004f0 <disable_l1_cache>:
		800004f0:	ee112f10 	mrc	15, 0, r2, cr1, cr0, {0}
		800004f4:	e3c22a01 	bic	r2, r2, #4096	; 0x1000
		800004f8:	e3c22004 	bic	r2, r2, #4
		800004fc:	ee012f10 	mcr	15, 0, r2, cr1, cr0, {0}
		80000500:	e12fff1e 	bx	lr
		*/
	------------------------------------------------------------------------------------------------------
	invalidate_l1_icache:
		mov r3, #0	/*往r3寄存器写入立即数0*/
		mcr p15, 0, r3, c8, c7, 0	/*协处理器p15的c8寄存器是只写寄存器.该条指令是"使无效整个数据和指令TLB"*/
		mcr p15, 0, r3, c7, c5, 0	/*协处理器p15的c7寄存器是只写寄存器.该条指令是"使无效整个指令cache"*/
		mcr p15, 0, r3, c7, c5, 6	/*清空整个跳转目标cache.即invalidate BP array.*/
		bx lr	/*bx:带状态切换的跳转指令.此处为返回到调用处.*/
		/*反汇编该段代码:
		80000504 <invalidata_l1_icache>:
		80000504:	e3a03000 	mov	r3, #0
		80000508:	ee083f17 	mcr	15, 0, r3, cr8, cr7, {0}
		8000050c:	ee073f15 	mcr	15, 0, r3, cr7, cr5, {0}
		80000510:	ee073fd5 	mcr	15, 0, r3, cr7, cr5, {6}
		80000514:	e12fff1e 	bx	lr
		*/
	------------------------------------------------------------------------------------------------------
***
# 2. MIPS汇编指令

实现在某个指定位置下一个断点的操作:

		la 	t0, 0xa01ffff0
		la 	t1, defy_test
		lw 	t2, (t1)
		sw 	t2, (t0)
		addiu 	t1, t1, 4
		lw 	t2, (t1)
		sw 	t2, 4(t0)

	defy_test:
		nop
		.word 0x1000ffff

反汇编得到:

	80000214:	3c098000 	lui	t1,0x8000
	80000218:	25290230 	addiu	t1,t1,560
	8000021c:	8d2a0000 	lw	t2,0(t1)
	80000220:	ad0a0000 	sw	t2,0(t0)
	80000224:	25290004 	addiu	t1,t1,4
	80000228:	8d2a0000 	lw	t2,0(t1)
	8000022c:	ad0a0004 	sw	t2,4(t0)
	
	80000230 <defy_test>:
	80000230:	00000000 	nop
	80000234:	1000ffff 	b	80000234 <defy_test+0x4>
	80000238:	3c088001 	lui	t0,0x8001
	8000023c:	2508ae68 	addiu	t0,t0,-20888
	80000240:	01000008 	jr	t0
	80000244:	00000000 	nop

# 3. 内嵌汇编

## 3.1 ARM内嵌汇编

**1.内嵌汇编断点指令**

	asm volatile(".word 0xebfffffe");	//ARM的断点

**2.内嵌汇编操作PC指针**

	//获取PC指针
	#define get_pc(x) {asm volatile("mov %0, r15" :"=r"(x));}
	/*
		mov %0	//编译器会自动选择一个空闲的CPU寄存器来装载x变量的地址.
				//理解为:该空闲寄存器就代表该变量.
		: "=r"(x)	//语法格式mov %0, r15 :"=r"(x)->output:"r"(x)->input:修饰
					//此处为代表output为x,即输出r15寄存器中的值给x.也即得到PC指针
		//PS:如果后面的input没有,中间的":"可以不需要
	*/
	//操作PC指针
	#define set_pc(x) {asm volatile("mov r15, %0" ::"r"(x));}
	//作为input,中间的":"是肯定需要的

## 3.2 MIPS内嵌汇编

**1.内嵌汇编断点指令**

	asm volatile(".word 0x1000ffff; nop");	//MIPS的断点

md 0x1801008c 4