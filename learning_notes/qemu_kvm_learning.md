# qemu_kvm learning

# Chapter  1. Qemu与KVM概述

## 1.1 虚拟化简介

### 1.1.1 虚拟化思想

虚拟化的主要思想:通过分层将底层复杂的、难用的资源虚拟抽象成简单的、易用的资源,提供给上层使用.

```
wine项目:让为windows编写的程序运行在linux上;
cygwin项目:让为linux编写的程序运行在windows上.
```

### 1.1.2 虚拟化简介

#### 1.1.2.1 进程

进程有自己独立的进程地址空间以及独立的CPU和寄存器,执行程序员编写的指令,完成一定的任务.因此,进程可以看成是一个独立的虚拟机.

```
1.一个进程在执行指令、访问内存的时候并不会影响其他进程;
2.每个进程都认为自己拥有整个机器;
3.进程的指令都是可以直接运行在硬件CPU上.
```

#### 1.1.2.2 模拟器

模拟器可以将为一种硬件指令集(ISA:Instruction Set Architecture)编译的程序运行在另一种硬件指令集上.

```
比如:应用程序在源ISA(e.g. ARM)上被编译出来,在模拟器的帮助下,运行在不同的目标ISA(e.g. x86)上.
```

模拟器有两种实现方式:

```
1.通过解释来实现:对程序的源ISA指令一条一条进行分析,然后执行相应的目标ISA指令;
2.通过二进制翻译实现:将程序中所有的源ISA指令全部翻译成目标ISA上具有相同功能的指令,然后在目标ISA指令机器上执行.
```

典型的模拟器:Qemu(Quick Emulator)的用户态程序模拟、Bochs模拟器等.

#### 1.1.2.3 高级语言虚拟机

高级语言虚拟机通常会定义一种全新的虚拟ISA,并在其中定义新的指令集、数据操作、寄存器的使用等类似物理ISA中的规范.其翻译过程为:

```
高级语言虚拟机源程序--->编译器--->字节码(编译器将源程序编译为虚拟ISA构成的字节码)
--->windows/linux平台虚拟机--->windows/linux OS.
```

虚拟机:用于将虚拟ISA指令转换为物理ISA指令.

典型的高级语言虚拟机:JVM虚拟机、Python虚拟机等.

#### 1.1.2.4 系统虚拟机

系统虚拟机能够提供一个完整的系统环境.

```
1.能够运行多个用户的多个进程;
2.通过系统虚拟化技术,能够在单个的宿主机硬件平台上运行多个虚拟机,每个虚拟机有着完整的虚拟机硬件(e.g.虚拟的CPU、内存、外设的);
3.虚拟机之间能够实现完整的隔离.
```

VMM(Virtual Machine Monitor,虚拟监控器):管理全局物理资源的软件.

```
VMM之于虚拟机就如同OS之于进程,VMM利用时分复用或空分复用的方法将硬件资源在各个虚拟机之间进行分配.
```

典型的系统虚拟化解决方案:VMware Workstation、Qemu、VirtualBox和HyperV等.

### 1.1.3 系统虚拟化的历史

KVM(Kernel Virtual Machine):2006年以色列初创公司(Qumranet)利用Intel的硬件虚拟化技术在Linux内核上开发了KVM,RedHat后来收购了Qumranet.

```
KVM具有架构精简、与Linux天然融合的优点.现在是一个非常成功的虚拟化VMM,广泛应用于各种开源云平台上,成为云计算的基石.
```

系统虚拟化方案介绍:

```
1.VMware Workstation:有大量用户,用户可以非常方便的在PC上构建一个虚拟机,安装各种OS;
2.VirtualBox:最早由德国公司开发,后来被甲骨文收购.优点是性能不错、开源.但是不如VMware Workstation稳定;
3.HyperV:微软提供的虚拟化解决方案,微软用它来构建自己的云计算平台;
4.Xen:早期的开源虚拟化方案,出现在各种硬件虚拟化技术之前,其发展不如KVM.
```

## 1.2 Qemu与KVM架构介绍

### 1.2.1 Qemu与KVM历史

#### 1.2.1.1 早期的Qemu

Qemu最开始是由法国程序员Fabrice Bellard开发的一个模拟器.Qemu能够完成用户程序模拟和系统虚拟化模拟.

```
1.用户程序模拟:Qemu能够将为一个平台编译的二进制文件运行在另一个不同的平台上:
	e.g. 一个ARM指令集的二进制程序,通过Qemu的TCG(Tiny Code Generator)引擎处理后,ARM指令被转换成TCG中间代码,
		然后再转换成目的平台的代码进行运行.
2.系统虚拟化模拟:指Qemu能够模拟一个完整的系统虚拟机:
	1.该虚拟机有自己的虚拟CPU、芯片组、虚拟内存以及各种外部设备;
	2.为虚拟机中运行的OS和应用程序呈现出与物理机完全一致的硬件视图.
```

Qemu能够模拟的平台包括:x86、ARM、MIPS、PPC等.早期的Qemu都是通过TCG来完成各种硬件平台的模拟,所有的虚拟机指令都需要经过Qemu的转换(全部由软件来实现).

#### 1.2.1.2 Qemu+KVM

Intel和AMD再2005年左右开始在CPU层面提供对系统虚拟化的支持(即:硬件虚拟化).

```
Intel在x86指令集的基础上增加了一套VMX扩展指令VT-x(即:硬件虚拟化指令).
```

KVM由以色列初创公司Qumranet基于新的硬件虚拟化指令集实现了KVM,并推广到linuxn内核社区.

```
1.KVM本身是一个内核模块,导出了一系列的接口到用户空间,用户空间可以使用这些接口创建虚拟机;
2.刚开始的KVM只负责最核心的CPU虚拟化和内存虚拟化部分(后面其他部分也有可能实现了),使用Qemu作为其用户态组件,负责完成大量
	外设的模拟.--->即KVM+Qemu方案.
```

### 1.2.2 Qemu+KVM架构

